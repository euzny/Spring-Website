<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="notice.mapper">

	<!-- 공지사항 전체 글 목록 조회 -->
<!-- 	<select id="list" resultType="notice.NoticeVO">
		select rownum no, n.*, (select name from member where id = n.writer ) name 
		from (select * from notice order by id ) n 
		order by no desc
	</select> -->

<!-- myBatis에서 sql 구문을 작성하여 id를 참조하는 include 기능을 사용해서 처리할 수 있음 -->	
	<sql id ="where_search">
		<!-- 제목에 '테스트' 문자가 있는것을 조회한다면.. where title like '테스트' -->
		<if test="search == 'title' or search == 'content' ">
			where ${search} like '%'||#{keyword}||'%'
		</if>
		<!-- 작성자에 '자' 문자가 있는것을 조회한다면  -->
		<if test="search== 'writer' ">
			where writer in (select id from member where name like '%'||#{keyword}||'%' )
		</if>
		
		<if test= "search == 'all' ">
			where title like '%'||#{keyword}||'%' or
			content like '%'||#{keyword}||'%'	or
			writer in (select id from member where name like '%'||#{keyword}||'%' )
		</if>
	
	</sql>
	
<!-- 페이지 처리된 글 목록 조회  -->
<select id="list" resultType="notice.NoticeVO">
	select * 
	from ( select rownum no, n.*, (select name from member where id = n.writer) name 
			from (select * from notice <include refid="where_search" />
			order by root, step desc) n <!-- id -> root, step 변경 -->
			order by no desc )
	where no between #{beginList} and #{endList}	
	<!-- no 값이 페이지 시작 목록번호와 끝 목록 번호 사이에 있는 값을 조회 -->
</select>
	
	<!-- 공지사항 신규 글 등록 처리 -->
	<insert id="insert">
		insert into notice(id, root, title, content, writer,filename,filepath)
		values(seq_notice.nextval,seq_notice.currval, #{title},#{content},#{writer},#{filename, jdbcType=VARCHAR},#{filepath, jdbcType=VARCHAR})
	<!-- Oracle 사용시 null 허용 컬럼에 값이 null이 들어가는 경우 부적합한 열 유형이라는 에러 메시지가 뜨게 됨. 
	이때 이를 해결하기 위하여 value1= #{value1, jdbcType=VARCHAR}, value2= #{value2, jdbcType=VARCHAR} 이런 식으로 값 뒤에 , jdbcType=VARCHAR를 붙여서 처리 -->
	</insert>
	
	<!-- 공지글 상세 내용 조회 -->
	<select id="detail" resultType="notice.NoticeVO">
		select n.*, (select name from member where id = n.writer ) name 
		from notice n  
		where id = #{id}
	</select>
	
	<!-- 상세화면 조회 전 조회수 증가 (변경) -->
	<update id="read">
		update notice set redcnt = redcnt + 1 where id = #{id} 
	</update>
	
	<!-- 해당 ID 공지글 삭제 -->
	<delete id="delete">
		delete from notice where id = #{id}
	</delete>
	
	<!-- 공지글 수정 -->
	<update id="update">
		update notice set title= #{title} , content = #{content}, filename= #{filename,jdbcType=VARCHAR}, filepath=#{filepath,jdbcType=VARCHAR}
		where id=#{id}
	</update>
	
	<!--  전체 공지글 수 조회 -->
	<select id="totalList" resultType = "integer">
		select count(*) from notice <include refid="where_search" />
	</select>
	
	<!-- 공지글에 대한 신규 답글 등록 -->
<insert id="reply_insert">
<!-- root : 원글의 id를 root로 그대로 담는다. -->
<!-- step : 동일한 root를 갖는 글에 대해 원글의 step보다 더 큰 step 을 가진 경우
         step +1로 변경한 후 원글의 step+1 로 저장한다. -->
<!-- indent : 원 글의 indent + 1 -->         


<!-- step은 동일한 root를 갖는 글에 대해 원글의 step보다 더 큰 step 을 가진 경우
         step +1로 변경한 후 원글의 step+1 로 저장한다. -->

<!-- insert 전 step 에 대한 값을 변경한 후 그 값을 insert 처리 -->
<!-- 오라클의 경우 여러 쿼리문을 작성할 경우 명령행을 구분하기 위하여 ;  을 붙여 사용 -->

<![CDATA[
	{
		call declare
		begin
			update notice set step = step +1 where root = #{root} and step > #{step};
			         
			insert into notice ( id, title, content, writer, filename, filepath, root, step, indent )
			values (seq_notice.nextval, #{title}, #{content}, #{writer},
					#{filename, jdbcType=VARCHAR}, #{filepath, jdbcType=VARCHAR}, 
					#{root}, #{step}+1, #{indent}+1);
		end
	}
]]>
</insert>
	
</mapper>